<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <title>Donut Chart - Flipped Labels</title>

    <!-- D3.js -->

    <script src="{{
  url_for('static', filename='js/d3.min.js') }}"></script>
   
   <script src="{{
  url_for('static', filename='js/d3pie.min.js') }}"></script>

 <link rel="stylesheet" href="{{ url_for('static', filename= 'css/style.css') }}">     
   <!-- Month names -->
    <link href='http://fonts.googleapis.com/css?family=Pacifico' rel='stylesheet' type='text/css'>

    
</head>

<body>

    <div id="chart"></div>

    <script>
        
		////////////////////////////////////////////////////////////
		//////////////////////// Set-up ////////////////////////////
		////////////////////////////////////////////////////////////

		var screenWidth = window.innerWidth;
        
        var ellipse_koef = 1.5	
		var margin = {left: 0, top: 0, right: 0, bottom: 0},
			width = Math.min(screenWidth, 500) - margin.left - margin.right,
			height = Math.min(screenWidth, 500) - margin.top - margin.bottom;
		var outerRadius = width * 0.5 - 100			
		var svg = d3.select("#chart").append("svg")
					.attr("width", (width + margin.left + margin.right))
					.attr("height", (height + margin.top + margin.bottom))
				   .append("g").attr("class", "wrapper")
					.attr("transform", "translate(" + (width / 2 + margin.left) + "," + (height / 2 + margin.top) + ")");
        
        function  getEllipseCoords(coorX, coorY, translateX, translateY) {
		    //console.log(Math.sqrt(ellipse_koef * ellipse_koef * coorY * coorY +  coorX * coorX ))
			//console.log(ellipse_koef * coorX)
		    newX = ellipse_koef * coorX / (Math.sqrt(ellipse_koef * ellipse_koef * coorY * coorY +  coorX * coorX )) * outerRadius ;
			newY = newX * coorY / coorX;
			return [newX, newY]
		}	

        ////////////////////////////////////////////////////////////// 
        ///////////////////// Data &  Scales ///////////////////////// 
        ////////////////////////////////////////////////////////////// 

        //Some random data
        var donutData = [
            {% for d in teams %} {
                "name": "{{d['name']}}",
                "value": {{d['value']}}
            },
            {% endfor %}    
            {% for d in groups %} {
                "name": "{{d['name']}}",
                "value": {{d['value']}}
            },
            {% endfor %}

             {
                "name": "fdfgsg",
                "value": 40

            }

        ];
	//Create a color scale
		var colorScale = d3.scale.linear()
		   .domain([1,3.5,6])
		   .range(["#2c7bb6", "#ffffbf", "#d7191c"])
		   .interpolate(d3.interpolateHcl);
        
		//Create an arc function   
		var arc = d3.svg.arc()
			.innerRadius(width * 0.5 - 160) 
			.outerRadius(outerRadius);

		//Turn the pie chart 90 degrees counter clockwise, so it starts at the left	
		var pie = d3.layout.pie()
			.startAngle(-90 * Math.PI/180)
			.endAngle(-90 * Math.PI/180 + 2*Math.PI)
			.value(function(d) { return d.value; })
			.padAngle(.01)
			.sort(null);
		 
		////////////////////////////////////////////////////////////// 
		//////////////////// Create Donut Chart ////////////////////// 
		////////////////////////////////////////////////////////////// 

		//Create the donut slices and also the invisible arcs for the text 
		svg.selectAll(".donutArcs")
			.data(pie(donutData))
		  .enter().append("path")
			.attr("class", "donutArcs")
			.attr("d", arc)
                  
			.style("fill", function(d,i) {
				if(i === 7) return "#CCCCCC"; //Other
				else return colorScale(i); 
                 
			})
		.each(function(d,i) {
			//Search pattern for everything between the start and the first capital L
			var firstArcSection = /(^.+?)L/; 
            var lastArcSection =  /L(.*?)Z/; 			
            console.log(d3.select(this).attr("d")) 
			//console.log((width / 2 + margin.left))
			
			
			//между М и A -->  преобразуем
            //между A и 0 0, 1 по X увеличивам на K
            //между 0 0,1 и L  преобразуем
            var firstDotEx =  /M(.*?)A/; 
			var radEll =  /A(.*?)0 0,1/; 
            var secondDotEx =  /0 0,1(.*?)L/;
			
			
			firstLoc = firstDotEx.exec(d3.select(this).attr("d"))[1]
			radLoc = radEll.exec(d3.select(this).attr("d"))[1]
			secLoc = secondDotEx.exec(d3.select(this).attr("d"))[1]
					
			
			var first = firstLoc.split(",");
	 	    newFirst = getEllipseCoords(parseFloat(first[0]), parseFloat(first[1]), 0, 0).join(",")
			
			var second = secLoc.split(",");
			newLast = getEllipseCoords(parseFloat(second[0]), parseFloat(second[1]), 0, 0).join(",")
			var rad = radLoc.split(",")
   			newRad = [ellipse_koef * rad[0], rad[1]].join(",")
			
			FirstPath = "M" + newFirst + "A" + newRad + "0 0, 1" + newLast + "L"
			//console.log(FirstPath)
			//Grab everything up to the first Line statement
                        //console.log(d3.select(this).attr("d"))
			
                        var newLoc =  /0 0,1(.*?)A/;
                        var newSec = newLoc.exec(d3.select(this).attr("d"))[1];  
                        var newArc = firstArcSection.exec( d3.select(this).attr("d") )[1];
						var lastArc = lastArcSection.exec( d3.select(this).attr("d") )[1];
			//Replace all the comma's so that IE can handle it
			newArc = newArc.replace(/,/g , " ");
			//console.log(newArc)
			//If the end angle lies beyond a quarter of a circle (90 degrees or pi/2) 
			//flip the end and start position
			if (d.endAngle > 90 * Math.PI/180) {
				var startLoc 	= /M(.*?)A/,		//Everything between the first capital M and first capital A
					middleLoc 	= /A(.*?)0 0 1/,	//Everything between the first capital A and 0 0 1
                                      
					endLoc 		= /0 0 1 (.*?)$/;	//Everything between the first 0 0 1 and the end of the string (denoted by $)
				//Flip the direction of the arc by switching the start en end point (and sweep flag)
				//of those elements that are below the horizontal line
				var newStart = endLoc.exec( newArc )[1];
				var newEnd = startLoc.exec( newArc )[1];
				var middleSec = middleLoc.exec( newArc )[1];
                                
				
				//Build up the new arc notation, set the sweep-flag to 0
				newArc = "M" + newStart + "A" + middleSec + "0 0 0 " + newEnd;
                       //         newArc = "M" + newSec + " Z";
                         //       console.log(newArc)
			}//if
                        //newArc = "M" + newStart + "A" + middleSec + "0 0 0 " + newEnd;
						 newArc = "M" + newSec + " Z";
						 newArc2 = FirstPath + lastArc + "Z"
			d3.select(this).append("path")
			     .attr("d", newArc )  
			//Create a new invisible arc that the text can flow along
			svg.append("path")
				.attr("class", "hiddenDonutArcs")
				.attr("id", "donutArc"+i)
				.attr("d", newArc)
				.style("fill", "none");
			
			svg.append("path")
				.attr("class", "ellipse")
				.attr("id", "donutArc"+i)
				.attr("d", newArc2)
				.style("fill", "#CCCCCC");	
				
		});
			
		//Append the label names on the outside
		svg.selectAll(".donutText")
			.data(pie(donutData))
		   .enter().append("text")
			.attr("class", "donutText")
                                        
			//Move the labels below the arcs for those slices with an end angle greater than 90 degrees
			.attr("dy", function(d,i) { return (d.endAngle > 90 * Math.PI/180 ? 18 : -11); })
                   
                   .append("textPath")
			.attr("startOffset","50%")
			
			.attr("xlink:href",function(d,i){return "#donutArc"+i;})
			.text(function(d){return d.data.name;});
	
	</script>
        
</body>

</html>
